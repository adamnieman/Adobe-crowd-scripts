//this requires scale.jsx//selected_symbols[i].bins =  new BINS(1, 2, 1.5).set_num_of_bins(20).generate_bins()	function BINS (_min_val, _max_val, _avg_val) {		var min_val = 0;		var max_val = 10;		var avg_val = 5		var scale = SCALE ()			.map_from([min_val, avg_val, max_val])			.map_to([-Math.PI, 0, Math.PI])		var range;		var num_of_bins = 10;		var bin_size;		var bins = [];		function _construct (_min_val, _max_val, _avg_val) {            $.writeln(_min_val+", "+typeof _min_val)			if (isNaN(_min_val) || isNaN(_max_val) || isNaN(avg_val)) {				return;			}			if (_min_val >= _max_val) {				_max_val = _min_val+10;			}			if (_avg_val > _max_val || _avg_val < min_val) {				_avg_val = _min_val + (_max_val-_min_val)/2			}			min_val = _min_val;			max_val = _max_val;			avg_val = _avg_val;			return this;		}		this.set_num_of_bins = function (_num_of_bins) {			if (isNaN(_num_of_bins) || _num_of_bins <= 0) {				return;			}			num_of_bins = Math.ceil(_num_of_bins);			return this;		}		this.generate_bins = function () {			scale.map_from([min_val, avg_val, max_val])			range = max_val - min_val;			bin_size = range/num_of_bins;			var sum_of_probability = 0			while (bins.length < num_of_bins) {				var bin = {};				bin.min = min_val + (bins.length*bin_size);				bin.max = bin.min + bin_size;				bin.mid = bin.min + (bin_size/2);				bin.probability = Math.cos(scale(bin.mid))+1				sum_of_probability += bin.probability;				bins.push(bin)			}			var i;			var l = bins.length;			for (i=0; i<l; i++) {				bins[i].probability /= sum_of_probability				if (bins[i-1]) {					bins[i].cumulative_probability = bins[i-1].cumulative_probability + bins[i].probability;				}				else {					bins[i].cumulative_probability = bins[i].probability;				}			}			return bins;		}		this.get = function () {			return bins;		}		_construct (_min_val, _max_val, _avg_val)	}